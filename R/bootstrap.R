# In this script I implement the bootstrapping process from Pascual et al.(2004). 
# 
# Bootstrapped samples are generated by recalculating the series with randomly drawn 
# residuals with replacement from the empirical distribution function of the residuals.
#
# For the forecasting process from any ARMA(p,q) model, the last p obs. are fixed and the predictions 
# are calculated for every bootstrapped series.

# Multicore support for the bootstrapping process.
library(parallel)

# Rescale original residuals from fit after Stine (1987).
rescale_arima_residuals <- function(arima_residuals,order,series){

        p <- order[1]
        scale_factor <- sqrt((length(series) - p) / (length(series) - 2 * p))
        arima_residuals <- arima_residuals * scale_factor
        arima_residuals

}

# Prepare resampling of an ARIMA Series, based on coefs. Only for orders larger than (0,0,0).
calc_Series <- function(ar_coefs,ma_coefs,arima_residuals,series = NA, is.forecast = F,n.ahead = 30,init_vector = NULL){

        if(is.forecast == T){

                if(length(init_vector) != 7)
                        stop("Vector of starting values must be 7 digits long (for now).")

                end <- n.ahead
                y <- append(init_vector,rep(NA,n.ahead))
                new_series <- y

        }
        else{
                # Coerce series to double, and init intermediate series vector.
                series <- as.double(series)
                y <- vector()

                # Padding for max AR(7) is hard coded!
                # I use a random draw from the series added to a random residuum to initialize the resampling.
                y[1:7] <- sample(series,7) + sample(arima_residuals,7)
                y <- append(y,series)

                # For Bootstrapping the series, the whole length is used.
                end <- length(series)

                # Bootstrapped series will be created recursively.
                new_series <- vector()
        }

        for(i in 8:(end + 7)){

                # Naïve, isn't it? 
                # To be honest I had no better idea for implementing a 
                # recursive time series generator based on ARMA coefs.
                new_series[i] <- ar_coefs[1]*y[i-1] +
                        ar_coefs[2]*y[i-2] +
                        ar_coefs[3]*y[i-3] +
                        ar_coefs[4]*y[i-4] +
                        ar_coefs[5]*y[i-5] +
                        ar_coefs[6]*y[i-6] +
                        ar_coefs[7]*y[i-7] +
                        sample(arima_residuals,1)+
                        ma_coefs[1]* sample(arima_residuals,1)+
                        ma_coefs[2]* sample(arima_residuals,1)+
                        ma_coefs[3]* sample(arima_residuals,1)+
                        ma_coefs[4]* sample(arima_residuals,1)+
                        ma_coefs[5]* sample(arima_residuals,1)+
                        ma_coefs[6]* sample(arima_residuals,1)+
                        ma_coefs[7]* sample(arima_residuals,1)

                # Update vector with forecast value.
                if(is.forecast == T){y <- new_series}

        }

        #Remove padding and return series.
        return(new_series[-(1:7)])

}

# Derive Coefficients from list.
make_ar_ma_coefs <- function(coefs,order){


        # Initialize empty order vectors
        ar_coefs <- ma_coefs <- rep(0,7)

        # ARMA(0,0)
        if(order[1] == 0 && order[2] == 0){
                return(list(ar_coefs = ar_coefs, ma_coefs = ma_coefs))
        }
        # AMRA(0,q)
        else if(order[2] == 0){
                ar_coefs <- coefs
                ar_coefs <- ar_coefs %>% 
                        append(rep(0,7)) %>% 
                        head(7)

        }
        # ARMA(p,0)
        else if(order[1] == 0){
                ma_coefs <- coefs
                ma_coefs <- ma_coefs %>% 
                        append(rep(0,7)) %>% 
                        head(7)
        }
        else{
                # Fill vectors according to order
                ar_coefs[1:order[1]] <- head(coefs,order[1])
                ma_coefs[1:order[2]] <- tail(coefs,order[2])
        }

        list(ar_coefs = ar_coefs, ma_coefs = ma_coefs)
}

# Make recursive col names
recursive_col_Names <- function(n, String){

        String <- as.character(String)
        series_Names <- rep(NA,n)
        for(i in 1:n){
                series_Names[i] <- paste0(String," ", i)
        }
        series_Names
}

# Create Bootstrap replicates of an ARIMA series. I only consider ARIMA(p,1,q) models
# as all my seris are stationary already, and thus dont need diffrencing.
bootsrapp_from_arima <- function(arima_residuals, series, coefs, order = c(0,0), n = 100, 
                                               out.sample = 30, parallel = F){

        # Rescale arima_residuals
        arima_residuals <- rescale_arima_residuals(arima_residuals,order,series)

        # Check whether residuals and series are of smae length.
        if(length(arima_residuals) != length(series))
                stop("Residuals must have same length as series")

        # Check that only arma order are supplied
        if(length(order) != 2)
                stop("Please only provide ARMA(p,q) orders")

        # Init result vector
        res <- matrix(ncol = length(series),nrow = n)

        # Intercept only -> ARIMA(0,0,0)
        if(sum(order) == 0){

                # Set coefs to 0 to just sample with a random draw from the error term
                coefs <- 0
                # This is just c + ê_t (intercept + resampled residuum)
                res <- replicate(n,sample(arima_residuals,length(series)))

        }

        else if(sum(order) != 0){

                # Other order exepct (0,0,0)
                arma  <- make_ar_ma_coefs(coefs,order)

                #Multicore support
                if(parallel == T){

                        cl <- makeCluster(detectCores()-1)

                        # Get library support needed to run the code
                        clusterEvalQ(cl,library(MASS))

                        clusterExport(cl, c("arma","arima_residuals","series"), envir = environment())
                        clusterExport(cl,"calc_Series", envir = .GlobalEnv)

                        res <- parSapply(cl,1:n, 
                                         function(i, ...){
                                                 x <- calc_Series(arma[[1]],arma[[2]],arima_residuals, series = series)
                                         }
                        )

                        stopCluster(cl)

                }

                else if (parallel == F){

                        # Resample Series
                        res <- replicate(n,calc_Series(arma[[1]],arma[[2]],arima_residuals, series = series))

                }

        }
        # Name the cols
        series_names <- recursive_col_Names(n,"Series")

        #Name the orders
        names(order) <- c("AR(p)","MA(q)")

        # Return Bootstrapped series and the orders for re-checking
        final <- list(bootSeries =  res, 
                      orders = order, 
                      coefs = coefs, 
                      origSeries = series, 
                      residuals = arima_residuals)
        class(final) <- "bootstrap_Arima"
        return(final)
}

# NOT RUN:
# f <- make_bootsrapped_series_from_arima(arima_residuals = auto.arima.list$CAC40$residuals,
# 										series = diff_list[[1]],
# 										coefs = coef(auto.arima.list$CAC40),
# 										order = c(auto.arima.list$CAC40$arma[1], auto.arima.list$CAC40$arma[2]), parallel = T)

# Calculate n days ahead from the bootstrapped series.
Boots_Predict <- function(bootstraps, n.ahead = 30, parallel = F){

        if(!(class(bootstraps) == "bootstrap_Arima")){

                stop("Supplied input is not of class 'boots_Arima'.\n
                     Did you use the 'make_bootsrapped_series_from_arima' function? ")

        }

        # Initialize result vector
        raw <- as.data.frame(matrix(ncol = n.ahead, nrow = ncol(bootstraps$bootSeries)))

        # Naming for result vector
        names(raw) <- recursive_col_Names(n.ahead,"T +")

        # Disassemble class 
        arima_residuals <- bootstraps$residuals
        bootMatrix <- bootstraps$bootSeries
        series <- c(bootstraps$origSeries)

        # Open a multi-core cluster for parallel computing.
        if(parallel == T){

                print(noquote("Init..."))
                cl <- makeCluster(detectCores())
                clusterExport(cl,c("bootMatrix","bootstraps"),envir = environment())

                print(noquote("Calculating..."))

                res <- parApply(cl = cl ,bootMatrix,2,arima,
                                order = c(bootstraps$orders[1],0,bootstraps$orders[2]),
                                method = "ML", 
                                SSinit = c("Rossignol2011"),
                                include.mean = F,
                                seasonal = list(order = c(0, 0, 0), period = NULL),
                                optim.method = "Nelder-Mead",
                                optim.control = list(trace = 1, maxit = 1000))#, fnscale = .1))
        }
        else if(parallel == F){

                res <- apply(bootMatrix,2,arima,
                             order = c(bootstraps$orders[1],0,bootstraps$orders[2]),
                             method = "ML", 
                             include.mean = F,
                             seasonal = list(order = c(0, 0, 0), period = NULL),
                             optim.method = "Nelder-Mead",
                             optim.control = list(maxit = 1000))

        }

        print(noquote("Done."))

        # If the coefs are all 0 the coef list has to be filled manually,
        # because the arima returns coef(fit) = numeric(0).
        if(bootstraps$orders[1] == 0 && bootstraps$orders[2] == 0){
                new_arima_coefs <- matrix(0,ncol = ncol(bootMatrix), nrow = 2)
        }
        else{

                # Get new coefs from resampling
                new_arima_coefs <- sapply(res,coef)
        }
        # Fix the last p observations from the original series.
        last_p_obs <- tail(series, bootstraps$orders[1])

        # Init vector for prediction.
        init <- rep(0,7)
        if(bootstraps$orders[1] != 0){
                init[1:bootstraps$orders[1]] <- rev(last_p_obs)
                init <- rev(init)
        }

        # Convert the coef list back to matrices with only one type (AR or MA).
        coef_list <- apply(new_arima_coefs,2,make_ar_ma_coefs, order = bootstraps$orders)
        coef_list <- sapply(coef_list,unlist)
        ar_coefs <- coef_list[1:7,]
        ma_coefs <- coef_list[8:14,]

        for(i in 1:ncol(bootMatrix)){

                raw[i,] <- calc_Series(ar_coefs[,i], 
                                       ma_coefs[,i], 
                                       arima_residuals = arima_residuals,
                                       is.forecast = T,
                                       series = NA,
                                       n.ahead = n.ahead,
                                       init_vector = init)

        }

        quants <- matrix(ncol = 2, nrow = n.ahead)
        for(i in 1:ncol(raw)){
                q <- quantile(raw[,i], probs = c(.05, .95))
                quants[i,1] <- q[1]
                quants[i,2] <- q[2]
        }
        summary <- apply(raw,2,mean)

        summary <- as.data.frame(cbind(summary,quants))
        names(summary) <- c("Mean","Lo 95", "Hi 95")

        res_tot <- list(rawPredicts = raw, Summary = summary)
        class(res_tot) <- "arimaBootstrapSummary"

        # Close multi-core cluster
        if(parallel == T){stopCluster(cl)}

        res_tot
}

# NOT RUN:
# x <- Boots_Predict(f, parallel = T)
