# Perform ADF test and print results in table
list_ADF <- function(list){
adf_results <- lapply(list, aTSA::adf.test, output = F)
res  <- matrix(ncol = 3)
#names(res) <- c("type1","lag","p.value")
for(i in 1:length(adf_results)){
type1 <- rep("type1",length(adf_results[[i]][[1]][,1]))
type2 <- rep("type2",length(adf_results[[i]][[2]][,1]))
type3 <- rep("type3",length(adf_results[[i]][[3]][,1]))
temp1  <- cbind(type1,adf_results[[i]][[1]][,c(1,3)])
temp2  <- cbind(type2,adf_results[[i]][[2]][,c(1,3)])
temp3  <- cbind(type3,adf_results[[i]][[3]][,c(1,3)])
temp_c <- rbind(temp1,temp2,temp3)
res <- rbind(res,temp_c)
}
#res <- res[res$p.val>.01,]
names(res) <- c("Index","test_type","lag","p.val")
res
}
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
# Perform ADF test and print results in table
list_ADF <- function(list){
adf_results <- lapply(list, aTSA::adf.test, output = F)
res  <- matrix(ncol = 3)
#names(res) <- c("type1","lag","p.value")
for(i in 1:length(adf_results)){
type1 <- rep("type1",length(adf_results[[i]][[1]][,1]))
type2 <- rep("type2",length(adf_results[[i]][[2]][,1]))
type3 <- rep("type3",length(adf_results[[i]][[3]][,1]))
temp1  <- cbind(type1,adf_results[[i]][[1]][,c(1,3)])
temp2  <- cbind(type2,adf_results[[i]][[2]][,c(1,3)])
temp3  <- cbind(type3,adf_results[[i]][[3]][,c(1,3)])
res <- rbind(res,temp1,temp2,temp3)
}
#res <- res[res$p.val>.01,]
names(res) <- c("Index","test_type","lag","p.val")
res
}
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
# Source the import and pre-transformations file.
source("~/Dropbox/Uni/Masterarbeit/Master_thesis/R/import_pre-transforms.R",echo = F)
# First Difference
diff_list <- lapply(ts_list, log) %>%
lapply(diff)
# Load libraries for augmented Dickey-Fuller Test
library(aTSA)
# Perform ADF test and print results in table
list_ADF <- function(list){
adf_results <- lapply(list, aTSA::adf.test, output = F)
res  <- matrix(ncol = 3)
index_name <- vector()
for(i in 1:length(adf_results)){
type1 <- rep("type1",length(adf_results[[i]][[1]][,1]))
type2 <- rep("type2",length(adf_results[[i]][[2]][,1]))
type3 <- rep("type3",length(adf_results[[i]][[3]][,1]))
temp1  <- cbind(type1,adf_results[[i]][[1]][,c(1,3)])
temp2  <- cbind(type2,adf_results[[i]][[2]][,c(1,3)])
temp3  <- cbind(type3,adf_results[[i]][[3]][,c(1,3)])
res <- rbind(res,temp1,temp2,temp3)
index_name <- append(index_name,rep(names(list)[i],
(length(type1)+length(type2)+length(type3))))
}
#res <- res[res$p.val>.01,]
res <- cbind(index_name,res)
names(res) <- c("Index","test_type","lag","p.val")
res
}
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
View(res)
# Perform ADF test and print results in table
list_ADF <- function(list){
adf_results <- lapply(list, aTSA::adf.test, output = F)
res  <- matrix(ncol = 3)
index_name <- vector()
for(i in 1:length(adf_results)){
type1 <- rep("type1",length(adf_results[[i]][[1]][,1]))
type2 <- rep("type2",length(adf_results[[i]][[2]][,1]))
type3 <- rep("type3",length(adf_results[[i]][[3]][,1]))
temp1  <- cbind(type1,adf_results[[i]][[1]][,c(1,3)])
temp2  <- cbind(type2,adf_results[[i]][[2]][,c(1,3)])
temp3  <- cbind(type3,adf_results[[i]][[3]][,c(1,3)])
res <- rbind(res,temp1,temp2,temp3)
index_name <- append(index_name,rep(names(list)[i],
(length(type1)+length(type2)+length(type3))))
}
#res <- res[res$p.val>.01,]
res <- cbind(index_name,res[-1,])
names(res) <- c("Index","test_type","lag","p.val")
res
}
a <- list_ADF(diff_list)
View(a)
# Source the import and pre-transformations file.
source("~/Dropbox/Uni/Masterarbeit/Master_thesis/R/import_pre-transforms.R",echo = F)
# First Difference
diff_list <- lapply(ts_list, log) %>%
lapply(diff)
# Load libraries for augmented Dickey-Fuller Test
library(aTSA)
?kpss.test
kpss.test(diff_list[[1]])
a <- kpss.test(diff_list[[1]])
View(a)
a <- tseries::kpss.test(diff_list[[1]])
View(a)
a <- aTSA::kpss.test(diff_list[[1]])
View(a)
# KPSS-Test
list_KPSS <- function(list){
KPSS_results <- lapply(list, aTSA::kpss.test, output = F)
res  <- matrix(ncol = 3)
index_name <- vector()
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,
rep(names(list)[i],
length(KPSS_results[[i]][,1])))
res  <-rbind(res,KPSS_results[[i]])
}
res <- cbind(index_name,res[-1,])
res
}
a <- list_KPSS(diff_list)
View(a)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
# KPSS-Test
list_KPSS <- function(list){
KPSS_results <- lapply(list, aTSA::kpss.test, output = F)
res  <- matrix(ncol = 3)
index_name <- vector()
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,
rep(names(list)[i],
length(KPSS_results[[i]][,1])))
res  <-rbind(res,KPSS_results[[i]])
}
res <- cbind(index_name,res[-1,])
as.data.drame(res)
}
a <- list_KPSS(diff_list)
# KPSS-Test
list_KPSS <- function(list){
KPSS_results <- lapply(list, aTSA::kpss.test, output = F)
res  <- matrix(ncol = 3)
index_name <- vector()
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,
rep(names(list)[i],
length(KPSS_results[[i]][,1])))
res  <-rbind(res,KPSS_results[[i]])
}
res <- cbind(index_name,res[-1,])
as.data.frame(res)
}
a <- list_KPSS(diff_list)
View(a)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
View(KPSS_results)
KPSS_results[["CAC40"]]
row.names(diff_list[[1]])
row.names(diff_list[[1]])
View(diff_list)
test <- kpss.test(diff_list[[1]])
row.names(test)
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,rep(names(list)[i],length(KPSS_results[[i]][,1])))
type_name <- append(type_name, row.names(KPSS_results[[i]]))
res  <-rbind(res,KPSS_results[[i]][,c(1,3)])
}
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,rep(names(list)[i],length(KPSS_results[[i]][,1])))
type_name <- append(type_name, row.names(KPSS_results[[i]]))
res  <-rbind(res,KPSS_results[[i]][,c(1,3)])
}
# KPSS-Test
list_KPSS <- function(list){
KPSS_results <- lapply(list, aTSA::kpss.test, output = F)
res  <- matrix(ncol = 3)
index_name <- vector()
type_name <- vector()
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,rep(names(list)[i],length(KPSS_results[[i]][,1])))
type_name <- append(type_name, row.names(KPSS_results[[i]]))
res  <-rbind(res,KPSS_results[[i]][,c(1,3)])
}
res <- cbind(index_name,type_name,res[-1,])
as.data.frame(res)
}
a <- list_KPSS(diff_list)
View(test)
# KPSS-Test
list_KPSS <- function(list){
KPSS_results <- lapply(list, aTSA::kpss.test, output = F)
res  <- matrix(ncol = 2)
index_name <- vector()
type_name <- vector()
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,rep(names(list)[i],length(KPSS_results[[i]][,1])))
type_name <- append(type_name, row.names(KPSS_results[[i]]))
res  <-rbind(res,KPSS_results[[i]][,c(1,3)])
}
res <- cbind(index_name,type_name,res[-1,])
as.data.frame(res)
}
a <- list_KPSS(diff_list)
View(a)
# KPSS-Test
list_KPSS <- function(list){
KPSS_results <- lapply(list, aTSA::kpss.test, output = F)
res  <- matrix(ncol = 2)
index_name <- vector()
type_name <- vector()
for(i in 1:length(KPSS_results)){
index_name <- append(index_name,rep(names(list)[i],length(KPSS_results[[i]][,1])))
type_name <- append(type_name, row.names(KPSS_results[[i]]))
res  <-rbind(res,KPSS_results[[i]][,c(1,3)])
}
res <- cbind(index_name,type_name,res[-1,])
row.names(res) <- NULL
as.data.frame(res)
}
a <- list_KPSS(diff_list)
View(a)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(skew_normal_optim)
View(skew_t_optim)
View(skew_normal_optim)
View(res)
View(res)
# Function
est_Par <- function(list){
res <- as.data.frame(matrix(ncol = 4+3+3, nrow = length(list)))
index_name <- vector()
for(i in 1:length(list)){
index_name <- append(index_name,names(list)[i])
skew_normal_optim <- optim(p0_1,sn_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
skew_t_optim <- optim(p0_2,st_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
skew_cauchy_optim <- optim(p0_1,sc_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
res[i,] <- c(skew_normal_optim$par,skew_t_optim$par,skew_cauchy_optim$par)
}
res <- cbind(index_name,res)
names(res) <- c("Index", "Location (Norm)","Scale (Norm)","Skew (Norm)",
"Location (t)","Scale (t)","Skew (t)","df(t)",
"Location (Cauchy)","Scale (Cauchy)","Skew (Cauchy)")
res
}
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(res)
# Function
est_Par <- function(list){
res <- as.data.frame(matrix(ncol = 4+3+3, nrow = length(list)))
index_name <- vector()
for(i in 1:length(list)){
index_name <- append(index_name,names(list)[i])
skew_normal_optim <- optim(p0_1,sn_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
skew_t_optim <- optim(p0_2,st_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
skew_cauchy_optim <- optim(p0_1,sc_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
res[i,] <- c(skew_normal_optim$par,skew_t_optim$par,skew_cauchy_optim$par)
}
res <- cbind(index_name,res)
names(res) <- c("Index", "Location (Norm)","Scale (Norm)","Skew (Norm)",
"Location (t)","Scale (t)","Skew (t)","df(t)",
"Location (Cauchy)","Scale (Cauchy)","Skew (Cauchy)")
res
}
a <- est_Par(diff_list)
View(a)
source('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
a <- est_Par(diff_list)
source('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
warnings()
View(a)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
View(AIC_res)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
View(AIC_res)
View(AIC_res)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
View(AIC_res)
?setNames
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
?names
?set_names
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
?aplly
?lapply
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
View(res)
debugSource('~/Dropbox/Uni/Masterarbeit/Master_thesis/R/descriptives.R', echo=TRUE)
View(AIC_res)
# Function
est_Par <- function(list){
res <- as.data.frame(matrix(ncol = 4+3+3, nrow = length(list)))
index_name <- vector()
# Information Criteria result matrices
AIC_res <- as.data.frame(matrix(ncol = 3))
BIC_res <- as.data.frame(matrix(ncol = 3))
HQC_res <- as.data.frame(matrix(ncol = 3))
ic_names <- c("Index","Skew-Normal","Skew-t","Skew-Cauchy")
# Information criteria functions
AIC <- function(optim){2*optim$value+2*length(optim$par)}
BIC <- function(optim,ts){2*optim$value+length(optim$par)*log(length(ts))}
HQC <- function(optim,ts){2*optim$value+2*length(optim$par)*log(log(length(ts)))}
for(i in 1:length(list)){
index_name <- append(index_name,names(list)[i])
sno <- optim(p0_1,
sn_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
sto <- optim(p0_2,
st_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
sco <- optim(p0_1,
sc_llik,
data = list[[i]],
method = "N",
control = list(maxit = 1000))
res[i,] <- c(sno$par,
sto$par,
sco$par)
# Information Criteria
# AIC
AIC_res <- rbind(AIC_res, c(AIC(sno), AIC(sto), AIC(sco)))
BIC_res <- rbind(BIC_res, c(BIC(sno,list[[i]]), BIC(sto,list[[i]]), BIC(sco, list[[i]])))
HQC_res <- rbind(HQC_res, c(HQC(sno,list[[i]]), HQC(sto, list[[i]]), HQC(sco,list[[i]])))
}
# Bind names vector to the Indices
AIC_res <- cbind(index_name,AIC_res[-1,])
BIC_res <- cbind(index_name,BIC_res[-1,])
HQC_res <- cbind(index_name,HQC_res[-1,])
# Name columns
names(AIC_res) <- ic_names
names(BIC_res) <- ic_names
names(HQC_res) <- ic_names
res <- cbind(index_name,res)
names(res) <- c("Index", "Location (Norm)","Scale (Norm)","Skew (Norm)",
"Location (t)","Scale (t)","Skew (t)","df(t)",
"Location (Cauchy)","Scale (Cauchy)","Skew (Cauchy)")
res_list <- list(Estimates = res, InformationCriteria = list(AIC = AIC_res,BIC = BIC_res,HQC = HQC_res))
res_list
}
a <- est_Par(diff_list)
View(a)
# Source the import and pre-transformations file.
source("~/Dropbox/Uni/Masterarbeit/Master_thesis/R/import_pre-transforms.R",echo = F)
plot(Acf(ts_list[[1]]))
plot(Acf(diff_list[[1]]))
?Acf
plot(Acf(diff_list[[1]]), main = "Hi")
plot(forecast::Acf(diff_list[[1]]), main = "Hi")
plot(forecast::Acf(diff_list[[1]], plot = F), main = "Hi")
plot(acf(diff_list[[1]], plot = F), main = "Hi")
plot(acf(diff_list[[1]], plot = F), main = "Hi", ylim = .2)
plot(acf(diff_list[[1]], plot = F), main = "Hi", ylim = c(-.2,.2))
?pdf
names(diff_list[[1]])
View(diff_list)
names(diff_list)
test <- arima(diff_list[[1]], order = c(1,0,1))
View(test)
?forecast
forecast(test, h = 60)
autoplot(forecast(test, h = 60))
hist(rnorm(1000))
hist(pnorm(rnorm(1000)))
hist(pnorm(rnorm(1000)))
hist(pnorm(rnorm(1000)))
hist(pnorm(rnorm(1000)))
hist(pnorm(rnorm(1000)))
hist(pnorm(rnorm(1000)))
hist(pnorm(rnorm(1000)))
plot(pnorm(rnorm(1000)))
qqnorm(pnorm(rnorm1000))
qqnorm(pnorm(rnorm(1000)))
.libPaths()
install.packages("rugarch")
install.packages("rugarch")
library(rugarch)
# Install the core Keras library + TensorFlow
library(keras)
model <- keras_model_sequential()
erm(model)
rm(model)
library(rurugarch)
library(rugarch)
?ugarchboot
con <- url("https://bookdown.org/rdpeng/rprogdatascience/interfaces-to-the-outside-world.html", "r")0
con <- url("http://bookdown.org/rdpeng/rprogdatascience/interfaces-to-the-outside-world.html", "r")0
con <- url("https://bookdown.org/rdpeng/rprogdatascience/interfaces-to-the-outside-world.html", "r")
x <- readLines(con)
head x
head(x)
seach()
search()
search(base)
x
con <- url("https://de.wikipedia.org", "r")
x <- readLines(con)
head(x)
search(
)
library(languageserver)
languageserver::run()
for (i i n1:10){print(i)}
for (i in 1:10){print(i)}
for (i in length(1:10)){print(i)}
exists(a)
a == NULL
exists("a")
a = c(1,1,2,2,3,3,4,4,5,5,6,6)
unique(a)
rep(a,4)
rep(c(a),4)
rep(unique(a),4)
unique(c(1,1,1,2,3,3,3,4,5,5))
# Load relevant packages and install them if not already done.
list_of_packages <- c("moments",
"tidyverse",
"lubridate",
"zoo",
"stats",
"aTSA",
"sn",
"forecast",
"parallel",
"foreach",
"keras",
"tfestimators",
"tfruns",
"rsample",
"recipes",
"rugarch"
)
# Recursive load of packages
invisible(
lapply(list_of_packages, library, character.only = T)
)
# Detect the number of cores on your system to enable multi-core processing.
# Last core is omitted to prevent system freeze during exec.
MC_CORES <- detectCores() - 1
############ ONLY FOR R-STUDIO USERS ##################
#
# If you use RStudio you need to set the working dir to the file path
# to enable relative paths.
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Create new environment to source the helper functions into.
# This avoids the .GlobalEnv to get too crowded.
funcEnv <- new.env()
# Vector with paths to the files to be sourced.
script_sources <- c("./import_pre-transforms.R",
"./descriptives.R",
"./auxf/helper.R",
"./exp_smoothing.R",
"./auxf/plotting.R",
"./ARIMA.R",
"./neural-nets.R")
# Source the functions and variables into the funcEnv
invisible(lapply(script_sources, source, local = funcEnv))
# Attach the environment to the search path
attach(funcEnv)
# Tidy up
rm(funcEnv, list_of_packages, script_sources)
if (exists("new_packages")) rm(new_packages)
# Global forecast horizon
OUT_SAMPLE <- 7
############################################################
#                 ARIMA assuming Skewed student t
#############################################################
cl <- makeCluster(MC_CORES)
# Create training and testing sets
train_test_arima_std <- make_training_and_testing_sets(diff_list, OUT_SAMPLE)
# Estimate arima orders up to order (12,12) with skew-t as underlying distribution
# Computationally demanding. Exec time ~20 minutes on 16 cores.
arima_sstd <- lapply(train_test_arima_std$train, autoarfima, ar.max = 12, ma.max = 12,
method = "partial", distribution.model = "sstd", include.mean = F,
criterion = "BIC", cluster = cl)
